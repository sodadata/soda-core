# Generated from /Users/tom/Code/soda-core/soda/core/soda/sodacl/antlr/SodaCLAntlr.g4 by ANTLR 4.9.3
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\39")
        buf.write("\u017f\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\3\2\3\2\3\2\3\2\3\2\5\2X\n\2\3\3")
        buf.write("\3\3\3\3\3\3\5\3^\n\3\3\3\3\3\3\3\3\3\5\3d\n\3\3\3\3\3")
        buf.write("\3\4\3\4\3\4\3\4\3\4\3\5\3\5\3\5\3\6\3\6\3\6\3\7\3\7\3")
        buf.write("\7\3\7\3\7\5\7x\n\7\3\7\3\7\3\7\3\7\5\7~\n\7\3\7\3\7\3")
        buf.write("\b\3\b\5\b\u0084\n\b\3\b\3\b\3\b\3\b\5\b\u008a\n\b\5\b")
        buf.write("\u008c\n\b\3\b\3\b\3\t\3\t\3\t\3\t\3\n\3\n\3\n\3\n\3\n")
        buf.write("\5\n\u0099\n\n\3\n\5\n\u009c\n\n\3\n\3\n\3\n\3\13\3\13")
        buf.write("\3\13\3\13\3\13\3\13\3\13\3\13\5\13\u00a9\n\13\3\f\3\f")
        buf.write("\3\r\3\r\3\r\3\16\3\16\3\17\3\17\5\17\u00b4\n\17\3\20")
        buf.write("\3\20\3\21\3\21\3\21\3\21\3\21\7\21\u00bd\n\21\f\21\16")
        buf.write("\21\u00c0\13\21\3\21\3\21\3\22\3\22\5\22\u00c6\n\22\3")
        buf.write("\23\3\23\5\23\u00ca\n\23\3\24\3\24\5\24\u00ce\n\24\3\24")
        buf.write("\3\24\3\24\5\24\u00d3\n\24\3\24\3\24\3\24\3\24\3\24\3")
        buf.write("\24\5\24\u00db\n\24\3\25\3\25\3\25\3\25\3\26\3\26\3\26")
        buf.write("\3\26\3\26\3\26\3\26\3\26\3\26\6\26\u00ea\n\26\r\26\16")
        buf.write("\26\u00eb\3\26\3\26\3\27\3\27\3\30\3\30\3\31\3\31\3\32")
        buf.write("\3\32\5\32\u00f8\n\32\3\32\5\32\u00fb\n\32\3\32\5\32\u00fe")
        buf.write("\n\32\3\33\3\33\3\33\6\33\u0103\n\33\r\33\16\33\u0104")
        buf.write("\3\33\5\33\u0108\n\33\3\34\3\34\3\34\3\34\3\34\3\34\3")
        buf.write("\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34")
        buf.write("\7\34\u011b\n\34\f\34\16\34\u011e\13\34\3\34\3\34\3\34")
        buf.write("\3\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34\7\34\u012b\n")
        buf.write("\34\f\34\16\34\u012e\13\34\3\34\3\34\5\34\u0132\n\34\3")
        buf.write("\35\3\35\3\36\3\36\3\37\3\37\3\37\3\37\3\37\5\37\u013d")
        buf.write("\n\37\3 \3 \3 \3 \3 \5 \u0144\n \3 \3 \3!\3!\3!\3!\3\"")
        buf.write("\3\"\3\"\3\"\3\"\3\"\3\"\3#\3#\3#\3#\3#\3$\3$\3$\3$\3")
        buf.write("$\3$\3$\3$\3$\3$\5$\u0162\n$\3%\3%\3%\3%\3%\3&\5&\u016a")
        buf.write("\n&\3&\3&\3\'\3\'\3\'\3\'\5\'\u0172\n\'\3\'\5\'\u0175")
        buf.write("\n\'\3\'\3\'\5\'\u0179\n\'\3(\3(\3)\3)\3)\2\2*\2\4\6\b")
        buf.write("\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\668")
        buf.write(":<>@BDFHJLNP\2\13\3\2!#\4\2$$((\4\2%%))\3\2\34\36\4\2")
        buf.write("\60\60\63\63\3\2.\64\3\2\13\r\3\2,-\4\2!#\65\67\2\u0181")
        buf.write("\2W\3\2\2\2\4Y\3\2\2\2\6g\3\2\2\2\bl\3\2\2\2\no\3\2\2")
        buf.write("\2\fr\3\2\2\2\16\u0083\3\2\2\2\20\u008f\3\2\2\2\22\u0093")
        buf.write("\3\2\2\2\24\u00a8\3\2\2\2\26\u00aa\3\2\2\2\30\u00ac\3")
        buf.write("\2\2\2\32\u00af\3\2\2\2\34\u00b1\3\2\2\2\36\u00b5\3\2")
        buf.write("\2\2 \u00b7\3\2\2\2\"\u00c5\3\2\2\2$\u00c9\3\2\2\2&\u00cd")
        buf.write("\3\2\2\2(\u00dc\3\2\2\2*\u00e9\3\2\2\2,\u00ef\3\2\2\2")
        buf.write(".\u00f1\3\2\2\2\60\u00f3\3\2\2\2\62\u00fd\3\2\2\2\64\u0102")
        buf.write("\3\2\2\2\66\u0131\3\2\2\28\u0133\3\2\2\2:\u0135\3\2\2")
        buf.write("\2<\u013c\3\2\2\2>\u013e\3\2\2\2@\u0147\3\2\2\2B\u014b")
        buf.write("\3\2\2\2D\u0152\3\2\2\2F\u0161\3\2\2\2H\u0163\3\2\2\2")
        buf.write("J\u0169\3\2\2\2L\u0178\3\2\2\2N\u017a\3\2\2\2P\u017c\3")
        buf.write("\2\2\2RX\5\n\6\2SX\5\f\7\2TX\5\16\b\2UX\5\66\34\2VX\5")
        buf.write("\4\3\2WR\3\2\2\2WS\3\2\2\2WT\3\2\2\2WU\3\2\2\2WV\3\2\2")
        buf.write("\2X\3\3\2\2\2YZ\7\3\2\2Z[\79\2\2[]\5P)\2\\^\5\6\4\2]\\")
        buf.write("\3\2\2\2]^\3\2\2\2^c\3\2\2\2_`\79\2\2`a\7\63\2\2ab\79")
        buf.write("\2\2bd\5\64\33\2c_\3\2\2\2cd\3\2\2\2de\3\2\2\2ef\7\2\2")
        buf.write("\3f\5\3\2\2\2gh\79\2\2hi\7\4\2\2ij\79\2\2jk\5P)\2k\7\3")
        buf.write("\2\2\2lm\79\2\2mn\7\34\2\2n\t\3\2\2\2op\7\65\2\2pq\7\2")
        buf.write("\2\3q\13\3\2\2\2rs\7\5\2\2st\79\2\2tw\5P)\2uv\79\2\2v")
        buf.write("x\5@!\2wu\3\2\2\2wx\3\2\2\2x}\3\2\2\2yz\79\2\2z{\7\33")
        buf.write("\2\2{|\79\2\2|~\5P)\2}y\3\2\2\2}~\3\2\2\2~\177\3\2\2\2")
        buf.write("\177\u0080\7\2\2\3\u0080\r\3\2\2\2\u0081\u0084\5\22\n")
        buf.write("\2\u0082\u0084\5\32\16\2\u0083\u0081\3\2\2\2\u0083\u0082")
        buf.write("\3\2\2\2\u0083\u0084\3\2\2\2\u0084\u0085\3\2\2\2\u0085")
        buf.write("\u008b\5\34\17\2\u0086\u0089\79\2\2\u0087\u008a\5$\23")
        buf.write("\2\u0088\u008a\5\20\t\2\u0089\u0087\3\2\2\2\u0089\u0088")
        buf.write("\3\2\2\2\u008a\u008c\3\2\2\2\u008b\u0086\3\2\2\2\u008b")
        buf.write("\u008c\3\2\2\2\u008c\u008d\3\2\2\2\u008d\u008e\7\2\2\3")
        buf.write("\u008e\17\3\2\2\2\u008f\u0090\7\63\2\2\u0090\u0091\79")
        buf.write("\2\2\u0091\u0092\7\6\2\2\u0092\21\3\2\2\2\u0093\u0094")
        buf.write("\7\37\2\2\u0094\u0098\79\2\2\u0095\u0096\5\24\13\2\u0096")
        buf.write("\u0097\79\2\2\u0097\u0099\3\2\2\2\u0098\u0095\3\2\2\2")
        buf.write("\u0098\u0099\3\2\2\2\u0099\u009b\3\2\2\2\u009a\u009c\5")
        buf.write("\30\r\2\u009b\u009a\3\2\2\2\u009b\u009c\3\2\2\2\u009c")
        buf.write("\u009d\3\2\2\2\u009d\u009e\7\27\2\2\u009e\u009f\79\2\2")
        buf.write("\u009f\23\3\2\2\2\u00a0\u00a1\5\26\f\2\u00a1\u00a2\79")
        buf.write("\2\2\u00a2\u00a3\7 \2\2\u00a3\u00a4\79\2\2\u00a4\u00a5")
        buf.write("\5N(\2\u00a5\u00a9\3\2\2\2\u00a6\u00a9\7\7\2\2\u00a7\u00a9")
        buf.write("\7\b\2\2\u00a8\u00a0\3\2\2\2\u00a8\u00a6\3\2\2\2\u00a8")
        buf.write("\u00a7\3\2\2\2\u00a9\25\3\2\2\2\u00aa\u00ab\t\2\2\2\u00ab")
        buf.write("\27\3\2\2\2\u00ac\u00ad\7\t\2\2\u00ad\u00ae\79\2\2\u00ae")
        buf.write("\31\3\2\2\2\u00af\u00b0\7\n\2\2\u00b0\33\3\2\2\2\u00b1")
        buf.write("\u00b3\5\36\20\2\u00b2\u00b4\5 \21\2\u00b3\u00b2\3\2\2")
        buf.write("\2\u00b3\u00b4\3\2\2\2\u00b4\35\3\2\2\2\u00b5\u00b6\5")
        buf.write("P)\2\u00b6\37\3\2\2\2\u00b7\u00b8\7(\2\2\u00b8\u00be\5")
        buf.write("\"\22\2\u00b9\u00ba\7*\2\2\u00ba\u00bb\79\2\2\u00bb\u00bd")
        buf.write("\5\"\22\2\u00bc\u00b9\3\2\2\2\u00bd\u00c0\3\2\2\2\u00be")
        buf.write("\u00bc\3\2\2\2\u00be\u00bf\3\2\2\2\u00bf\u00c1\3\2\2\2")
        buf.write("\u00c0\u00be\3\2\2\2\u00c1\u00c2\7)\2\2\u00c2!\3\2\2\2")
        buf.write("\u00c3\u00c6\5J&\2\u00c4\u00c6\5P)\2\u00c5\u00c3\3\2\2")
        buf.write("\2\u00c5\u00c4\3\2\2\2\u00c6#\3\2\2\2\u00c7\u00ca\5(\25")
        buf.write("\2\u00c8\u00ca\5&\24\2\u00c9\u00c7\3\2\2\2\u00c9\u00c8")
        buf.write("\3\2\2\2\u00ca%\3\2\2\2\u00cb\u00cc\7\32\2\2\u00cc\u00ce")
        buf.write("\79\2\2\u00cd\u00cb\3\2\2\2\u00cd\u00ce\3\2\2\2\u00ce")
        buf.write("\u00cf\3\2\2\2\u00cf\u00d0\7\31\2\2\u00d0\u00d2\79\2\2")
        buf.write("\u00d1\u00d3\t\3\2\2\u00d2\u00d1\3\2\2\2\u00d2\u00d3\3")
        buf.write("\2\2\2\u00d3\u00d4\3\2\2\2\u00d4\u00d5\5\62\32\2\u00d5")
        buf.write("\u00d6\79\2\2\u00d6\u00d7\7\30\2\2\u00d7\u00d8\79\2\2")
        buf.write("\u00d8\u00da\5\62\32\2\u00d9\u00db\t\4\2\2\u00da\u00d9")
        buf.write("\3\2\2\2\u00da\u00db\3\2\2\2\u00db\'\3\2\2\2\u00dc\u00dd")
        buf.write("\5\60\31\2\u00dd\u00de\79\2\2\u00de\u00df\5\62\32\2\u00df")
        buf.write(")\3\2\2\2\u00e0\u00e1\5,\27\2\u00e1\u00e2\79\2\2\u00e2")
        buf.write("\u00e3\5.\30\2\u00e3\u00e4\79\2\2\u00e4\u00e5\5\62\32")
        buf.write("\2\u00e5\u00e6\79\2\2\u00e6\u00e7\5.\30\2\u00e7\u00e8")
        buf.write("\79\2\2\u00e8\u00ea\3\2\2\2\u00e9\u00e0\3\2\2\2\u00ea")
        buf.write("\u00eb\3\2\2\2\u00eb\u00e9\3\2\2\2\u00eb\u00ec\3\2\2\2")
        buf.write("\u00ec\u00ed\3\2\2\2\u00ed\u00ee\5,\27\2\u00ee+\3\2\2")
        buf.write("\2\u00ef\u00f0\t\5\2\2\u00f0-\3\2\2\2\u00f1\u00f2\t\6")
        buf.write("\2\2\u00f2/\3\2\2\2\u00f3\u00f4\t\7\2\2\u00f4\61\3\2\2")
        buf.write("\2\u00f5\u00fa\5J&\2\u00f6\u00f8\79\2\2\u00f7\u00f6\3")
        buf.write("\2\2\2\u00f7\u00f8\3\2\2\2\u00f8\u00f9\3\2\2\2\u00f9\u00fb")
        buf.write("\7+\2\2\u00fa\u00f7\3\2\2\2\u00fa\u00fb\3\2\2\2\u00fb")
        buf.write("\u00fe\3\2\2\2\u00fc\u00fe\5\64\33\2\u00fd\u00f5\3\2\2")
        buf.write("\2\u00fd\u00fc\3\2\2\2\u00fe\63\3\2\2\2\u00ff\u0100\5")
        buf.write("N(\2\u0100\u0101\t\b\2\2\u0101\u0103\3\2\2\2\u0102\u00ff")
        buf.write("\3\2\2\2\u0103\u0104\3\2\2\2\u0104\u0102\3\2\2\2\u0104")
        buf.write("\u0105\3\2\2\2\u0105\u0107\3\2\2\2\u0106\u0108\5N(\2\u0107")
        buf.write("\u0106\3\2\2\2\u0107\u0108\3\2\2\2\u0108\65\3\2\2\2\u0109")
        buf.write("\u010a\7\16\2\2\u010a\u010b\79\2\2\u010b\u010c\58\35\2")
        buf.write("\u010c\u010d\79\2\2\u010d\u010e\7\17\2\2\u010e\u010f\7")
        buf.write("9\2\2\u010f\u0110\5P)\2\u0110\u0111\79\2\2\u0111\u0112")
        buf.write("\5:\36\2\u0112\u0132\3\2\2\2\u0113\u0114\7\16\2\2\u0114")
        buf.write("\u0115\79\2\2\u0115\u0116\7(\2\2\u0116\u011c\58\35\2\u0117")
        buf.write("\u0118\7*\2\2\u0118\u0119\79\2\2\u0119\u011b\58\35\2\u011a")
        buf.write("\u0117\3\2\2\2\u011b\u011e\3\2\2\2\u011c\u011a\3\2\2\2")
        buf.write("\u011c\u011d\3\2\2\2\u011d\u011f\3\2\2\2\u011e\u011c\3")
        buf.write("\2\2\2\u011f\u0120\7)\2\2\u0120\u0121\79\2\2\u0121\u0122")
        buf.write("\7\17\2\2\u0122\u0123\79\2\2\u0123\u0124\5P)\2\u0124\u0125")
        buf.write("\79\2\2\u0125\u0126\7(\2\2\u0126\u012c\5:\36\2\u0127\u0128")
        buf.write("\7*\2\2\u0128\u0129\79\2\2\u0129\u012b\5:\36\2\u012a\u0127")
        buf.write("\3\2\2\2\u012b\u012e\3\2\2\2\u012c\u012a\3\2\2\2\u012c")
        buf.write("\u012d\3\2\2\2\u012d\u012f\3\2\2\2\u012e\u012c\3\2\2\2")
        buf.write("\u012f\u0130\7)\2\2\u0130\u0132\3\2\2\2\u0131\u0109\3")
        buf.write("\2\2\2\u0131\u0113\3\2\2\2\u0132\67\3\2\2\2\u0133\u0134")
        buf.write("\5P)\2\u01349\3\2\2\2\u0135\u0136\5P)\2\u0136;\3\2\2\2")
        buf.write("\u0137\u013d\5> \2\u0138\u013d\5D#\2\u0139\u013d\5B\"")
        buf.write("\2\u013a\u013d\5F$\2\u013b\u013d\5H%\2\u013c\u0137\3\2")
        buf.write("\2\2\u013c\u0138\3\2\2\2\u013c\u0139\3\2\2\2\u013c\u013a")
        buf.write("\3\2\2\2\u013c\u013b\3\2\2\2\u013d=\3\2\2\2\u013e\u013f")
        buf.write("\7\20\2\2\u013f\u0140\79\2\2\u0140\u0143\5P)\2\u0141\u0142")
        buf.write("\79\2\2\u0142\u0144\5@!\2\u0143\u0141\3\2\2\2\u0143\u0144")
        buf.write("\3\2\2\2\u0144\u0145\3\2\2\2\u0145\u0146\7\2\2\3\u0146")
        buf.write("?\3\2\2\2\u0147\u0148\7$\2\2\u0148\u0149\5P)\2\u0149\u014a")
        buf.write("\7%\2\2\u014aA\3\2\2\2\u014b\u014c\7\21\2\2\u014c\u014d")
        buf.write("\79\2\2\u014d\u014e\5P)\2\u014e\u014f\79\2\2\u014f\u0150")
        buf.write("\5@!\2\u0150\u0151\7\2\2\3\u0151C\3\2\2\2\u0152\u0153")
        buf.write("\7\22\2\2\u0153\u0154\79\2\2\u0154\u0155\5P)\2\u0155\u0156")
        buf.write("\7\2\2\3\u0156E\3\2\2\2\u0157\u0158\7\23\2\2\u0158\u0159")
        buf.write("\79\2\2\u0159\u015a\5P)\2\u015a\u015b\7\2\2\3\u015b\u0162")
        buf.write("\3\2\2\2\u015c\u015d\7\24\2\2\u015d\u015e\79\2\2\u015e")
        buf.write("\u015f\5P)\2\u015f\u0160\7\2\2\3\u0160\u0162\3\2\2\2\u0161")
        buf.write("\u0157\3\2\2\2\u0161\u015c\3\2\2\2\u0162G\3\2\2\2\u0163")
        buf.write("\u0164\7\25\2\2\u0164\u0165\79\2\2\u0165\u0166\5P)\2\u0166")
        buf.write("\u0167\7\2\2\3\u0167I\3\2\2\2\u0168\u016a\t\t\2\2\u0169")
        buf.write("\u0168\3\2\2\2\u0169\u016a\3\2\2\2\u016a\u016b\3\2\2\2")
        buf.write("\u016b\u016c\5L\'\2\u016cK\3\2\2\2\u016d\u0179\5N(\2\u016e")
        buf.write("\u016f\78\2\2\u016f\u0171\7\26\2\2\u0170\u0172\78\2\2")
        buf.write("\u0171\u0170\3\2\2\2\u0171\u0172\3\2\2\2\u0172\u0179\3")
        buf.write("\2\2\2\u0173\u0175\78\2\2\u0174\u0173\3\2\2\2\u0174\u0175")
        buf.write("\3\2\2\2\u0175\u0176\3\2\2\2\u0176\u0177\7\26\2\2\u0177")
        buf.write("\u0179\78\2\2\u0178\u016d\3\2\2\2\u0178\u016e\3\2\2\2")
        buf.write("\u0178\u0174\3\2\2\2\u0179M\3\2\2\2\u017a\u017b\78\2\2")
        buf.write("\u017bO\3\2\2\2\u017c\u017d\t\n\2\2\u017dQ\3\2\2\2$W]")
        buf.write("cw}\u0083\u0089\u008b\u0098\u009b\u00a8\u00b3\u00be\u00c5")
        buf.write("\u00c9\u00cd\u00d2\u00da\u00eb\u00f7\u00fa\u00fd\u0104")
        buf.write("\u0107\u011c\u012c\u0131\u013c\u0143\u0161\u0169\u0171")
        buf.write("\u0174\u0178")
        return buf.getvalue()


class SodaCLAntlrParser ( Parser ):

    grammarFileName = "SodaCLAntlr.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'freshness using'", "'with'", "'row_count same as'", 
                     "'default'", "'same day last week'", "'same day last month'", 
                     "'percent'", "'anomaly score for '", "'d'", "'h'", 
                     "'m'", "'values in'", "'must exist in'", "'checks for'", 
                     "'filter'", "'configurations for'", "'for each dataset'", 
                     "'for each table'", "'for each column'", "'.'", "'for'", 
                     "'and'", "'between'", "'not'", "'in'", "'warn'", "'fail'", 
                     "'pass'", "'change'", "'last'", "'avg'", "'min'", "'max'", 
                     "'['", "']'", "'{'", "'}'", "'('", "')'", "','", "'%'", 
                     "'+'", "'-'", "'!='", "'<>'", "'<='", "'>='", "'='", 
                     "'<'", "'>'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "' '" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "FOR", "AND", "BETWEEN", "NOT", "IN", 
                      "WARN", "FAIL", "PASS", "CHANGE", "LAST", "AVG", "MIN", 
                      "MAX", "SQUARE_LEFT", "SQUARE_RIGHT", "CURLY_LEFT", 
                      "CURLY_RIGHT", "ROUND_LEFT", "ROUND_RIGHT", "COMMA", 
                      "PERCENT", "PLUS", "MINUS", "NOT_EQUAL", "NOT_EQUAL_SQL", 
                      "LTE", "GTE", "EQUAL", "LT", "GT", "IDENTIFIER_DOUBLE_QUOTE", 
                      "IDENTIFIER_BACKTICK", "IDENTIFIER_UNQUOTED", "DIGITS", 
                      "S" ]

    RULE_check = 0
    RULE_freshness_check = 1
    RULE_freshness_variable = 2
    RULE_warn_qualifier = 3
    RULE_failed_rows_check = 4
    RULE_row_count_comparison_check = 5
    RULE_metric_check = 6
    RULE_default_anomaly_threshold = 7
    RULE_change_over_time = 8
    RULE_change_over_time_config = 9
    RULE_change_aggregation = 10
    RULE_percent = 11
    RULE_anomaly_score = 12
    RULE_metric = 13
    RULE_metric_name = 14
    RULE_metric_args = 15
    RULE_metric_arg = 16
    RULE_threshold = 17
    RULE_between_threshold = 18
    RULE_comparator_threshold = 19
    RULE_zones_threshold = 20
    RULE_outcome = 21
    RULE_zone_comparator = 22
    RULE_comparator = 23
    RULE_threshold_value = 24
    RULE_freshness_threshold_value = 25
    RULE_reference_check = 26
    RULE_source_column_name = 27
    RULE_target_column_name = 28
    RULE_section_header = 29
    RULE_table_checks_header = 30
    RULE_partition_name = 31
    RULE_table_filter_header = 32
    RULE_column_configurations_header = 33
    RULE_checks_for_each_dataset_header = 34
    RULE_checks_for_each_column_header = 35
    RULE_signed_number = 36
    RULE_number = 37
    RULE_integer = 38
    RULE_identifier = 39

    ruleNames =  [ "check", "freshness_check", "freshness_variable", "warn_qualifier", 
                   "failed_rows_check", "row_count_comparison_check", "metric_check", 
                   "default_anomaly_threshold", "change_over_time", "change_over_time_config", 
                   "change_aggregation", "percent", "anomaly_score", "metric", 
                   "metric_name", "metric_args", "metric_arg", "threshold", 
                   "between_threshold", "comparator_threshold", "zones_threshold", 
                   "outcome", "zone_comparator", "comparator", "threshold_value", 
                   "freshness_threshold_value", "reference_check", "source_column_name", 
                   "target_column_name", "section_header", "table_checks_header", 
                   "partition_name", "table_filter_header", "column_configurations_header", 
                   "checks_for_each_dataset_header", "checks_for_each_column_header", 
                   "signed_number", "number", "integer", "identifier" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    FOR=21
    AND=22
    BETWEEN=23
    NOT=24
    IN=25
    WARN=26
    FAIL=27
    PASS=28
    CHANGE=29
    LAST=30
    AVG=31
    MIN=32
    MAX=33
    SQUARE_LEFT=34
    SQUARE_RIGHT=35
    CURLY_LEFT=36
    CURLY_RIGHT=37
    ROUND_LEFT=38
    ROUND_RIGHT=39
    COMMA=40
    PERCENT=41
    PLUS=42
    MINUS=43
    NOT_EQUAL=44
    NOT_EQUAL_SQL=45
    LTE=46
    GTE=47
    EQUAL=48
    LT=49
    GT=50
    IDENTIFIER_DOUBLE_QUOTE=51
    IDENTIFIER_BACKTICK=52
    IDENTIFIER_UNQUOTED=53
    DIGITS=54
    S=55

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.3")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class CheckContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def failed_rows_check(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Failed_rows_checkContext,0)


        def row_count_comparison_check(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Row_count_comparison_checkContext,0)


        def metric_check(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Metric_checkContext,0)


        def reference_check(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Reference_checkContext,0)


        def freshness_check(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Freshness_checkContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_check

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCheck" ):
                listener.enterCheck(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCheck" ):
                listener.exitCheck(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCheck" ):
                return visitor.visitCheck(self)
            else:
                return visitor.visitChildren(self)




    def check(self):

        localctx = SodaCLAntlrParser.CheckContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_check)
        try:
            self.state = 85
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 80
                self.failed_rows_check()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 81
                self.row_count_comparison_check()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 82
                self.metric_check()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 83
                self.reference_check()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 84
                self.freshness_check()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Freshness_checkContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def freshness_variable(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Freshness_variableContext,0)


        def LT(self):
            return self.getToken(SodaCLAntlrParser.LT, 0)

        def freshness_threshold_value(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Freshness_threshold_valueContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_freshness_check

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFreshness_check" ):
                listener.enterFreshness_check(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFreshness_check" ):
                listener.exitFreshness_check(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFreshness_check" ):
                return visitor.visitFreshness_check(self)
            else:
                return visitor.visitChildren(self)




    def freshness_check(self):

        localctx = SodaCLAntlrParser.Freshness_checkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_freshness_check)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 87
            self.match(SodaCLAntlrParser.T__0)
            self.state = 88
            self.match(SodaCLAntlrParser.S)
            self.state = 89
            self.identifier()
            self.state = 91
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.state = 90
                self.freshness_variable()


            self.state = 97
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SodaCLAntlrParser.S:
                self.state = 93
                self.match(SodaCLAntlrParser.S)
                self.state = 94
                self.match(SodaCLAntlrParser.LT)
                self.state = 95
                self.match(SodaCLAntlrParser.S)
                self.state = 96
                self.freshness_threshold_value()


            self.state = 99
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Freshness_variableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_freshness_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFreshness_variable" ):
                listener.enterFreshness_variable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFreshness_variable" ):
                listener.exitFreshness_variable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFreshness_variable" ):
                return visitor.visitFreshness_variable(self)
            else:
                return visitor.visitChildren(self)




    def freshness_variable(self):

        localctx = SodaCLAntlrParser.Freshness_variableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_freshness_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 101
            self.match(SodaCLAntlrParser.S)
            self.state = 102
            self.match(SodaCLAntlrParser.T__1)
            self.state = 103
            self.match(SodaCLAntlrParser.S)
            self.state = 104
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Warn_qualifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def WARN(self):
            return self.getToken(SodaCLAntlrParser.WARN, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_warn_qualifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWarn_qualifier" ):
                listener.enterWarn_qualifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWarn_qualifier" ):
                listener.exitWarn_qualifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWarn_qualifier" ):
                return visitor.visitWarn_qualifier(self)
            else:
                return visitor.visitChildren(self)




    def warn_qualifier(self):

        localctx = SodaCLAntlrParser.Warn_qualifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_warn_qualifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 106
            self.match(SodaCLAntlrParser.S)
            self.state = 107
            self.match(SodaCLAntlrParser.WARN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Failed_rows_checkContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER_DOUBLE_QUOTE(self):
            return self.getToken(SodaCLAntlrParser.IDENTIFIER_DOUBLE_QUOTE, 0)

        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_failed_rows_check

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFailed_rows_check" ):
                listener.enterFailed_rows_check(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFailed_rows_check" ):
                listener.exitFailed_rows_check(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFailed_rows_check" ):
                return visitor.visitFailed_rows_check(self)
            else:
                return visitor.visitChildren(self)




    def failed_rows_check(self):

        localctx = SodaCLAntlrParser.Failed_rows_checkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_failed_rows_check)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 109
            self.match(SodaCLAntlrParser.IDENTIFIER_DOUBLE_QUOTE)
            self.state = 110
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Row_count_comparison_checkContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SodaCLAntlrParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,i)


        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def partition_name(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Partition_nameContext,0)


        def IN(self):
            return self.getToken(SodaCLAntlrParser.IN, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_row_count_comparison_check

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRow_count_comparison_check" ):
                listener.enterRow_count_comparison_check(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRow_count_comparison_check" ):
                listener.exitRow_count_comparison_check(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRow_count_comparison_check" ):
                return visitor.visitRow_count_comparison_check(self)
            else:
                return visitor.visitChildren(self)




    def row_count_comparison_check(self):

        localctx = SodaCLAntlrParser.Row_count_comparison_checkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_row_count_comparison_check)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 112
            self.match(SodaCLAntlrParser.T__2)
            self.state = 113
            self.match(SodaCLAntlrParser.S)
            self.state = 114
            self.identifier()
            self.state = 117
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.state = 115
                self.match(SodaCLAntlrParser.S)
                self.state = 116
                self.partition_name()


            self.state = 123
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SodaCLAntlrParser.S:
                self.state = 119
                self.match(SodaCLAntlrParser.S)
                self.state = 120
                self.match(SodaCLAntlrParser.IN)
                self.state = 121
                self.match(SodaCLAntlrParser.S)
                self.state = 122
                self.identifier()


            self.state = 125
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Metric_checkContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def metric(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.MetricContext,0)


        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def change_over_time(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Change_over_timeContext,0)


        def anomaly_score(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Anomaly_scoreContext,0)


        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def threshold(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.ThresholdContext,0)


        def default_anomaly_threshold(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Default_anomaly_thresholdContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_metric_check

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetric_check" ):
                listener.enterMetric_check(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetric_check" ):
                listener.exitMetric_check(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetric_check" ):
                return visitor.visitMetric_check(self)
            else:
                return visitor.visitChildren(self)




    def metric_check(self):

        localctx = SodaCLAntlrParser.Metric_checkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_metric_check)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SodaCLAntlrParser.CHANGE]:
                self.state = 127
                self.change_over_time()
                pass
            elif token in [SodaCLAntlrParser.T__7]:
                self.state = 128
                self.anomaly_score()
                pass
            elif token in [SodaCLAntlrParser.AVG, SodaCLAntlrParser.MIN, SodaCLAntlrParser.MAX, SodaCLAntlrParser.IDENTIFIER_DOUBLE_QUOTE, SodaCLAntlrParser.IDENTIFIER_BACKTICK, SodaCLAntlrParser.IDENTIFIER_UNQUOTED]:
                pass
            else:
                pass
            self.state = 131
            self.metric()
            self.state = 137
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SodaCLAntlrParser.S:
                self.state = 132
                self.match(SodaCLAntlrParser.S)
                self.state = 135
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
                if la_ == 1:
                    self.state = 133
                    self.threshold()
                    pass

                elif la_ == 2:
                    self.state = 134
                    self.default_anomaly_threshold()
                    pass




            self.state = 139
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Default_anomaly_thresholdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(SodaCLAntlrParser.LT, 0)

        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_default_anomaly_threshold

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault_anomaly_threshold" ):
                listener.enterDefault_anomaly_threshold(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault_anomaly_threshold" ):
                listener.exitDefault_anomaly_threshold(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefault_anomaly_threshold" ):
                return visitor.visitDefault_anomaly_threshold(self)
            else:
                return visitor.visitChildren(self)




    def default_anomaly_threshold(self):

        localctx = SodaCLAntlrParser.Default_anomaly_thresholdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_default_anomaly_threshold)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 141
            self.match(SodaCLAntlrParser.LT)
            self.state = 142
            self.match(SodaCLAntlrParser.S)
            self.state = 143
            self.match(SodaCLAntlrParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Change_over_timeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHANGE(self):
            return self.getToken(SodaCLAntlrParser.CHANGE, 0)

        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def FOR(self):
            return self.getToken(SodaCLAntlrParser.FOR, 0)

        def change_over_time_config(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Change_over_time_configContext,0)


        def percent(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.PercentContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_change_over_time

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChange_over_time" ):
                listener.enterChange_over_time(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChange_over_time" ):
                listener.exitChange_over_time(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChange_over_time" ):
                return visitor.visitChange_over_time(self)
            else:
                return visitor.visitChildren(self)




    def change_over_time(self):

        localctx = SodaCLAntlrParser.Change_over_timeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_change_over_time)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 145
            self.match(SodaCLAntlrParser.CHANGE)
            self.state = 146
            self.match(SodaCLAntlrParser.S)
            self.state = 150
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SodaCLAntlrParser.T__4) | (1 << SodaCLAntlrParser.T__5) | (1 << SodaCLAntlrParser.AVG) | (1 << SodaCLAntlrParser.MIN) | (1 << SodaCLAntlrParser.MAX))) != 0):
                self.state = 147
                self.change_over_time_config()
                self.state = 148
                self.match(SodaCLAntlrParser.S)


            self.state = 153
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SodaCLAntlrParser.T__6:
                self.state = 152
                self.percent()


            self.state = 155
            self.match(SodaCLAntlrParser.FOR)
            self.state = 156
            self.match(SodaCLAntlrParser.S)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Change_over_time_configContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def change_aggregation(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Change_aggregationContext,0)


        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def LAST(self):
            return self.getToken(SodaCLAntlrParser.LAST, 0)

        def integer(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IntegerContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_change_over_time_config

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChange_over_time_config" ):
                listener.enterChange_over_time_config(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChange_over_time_config" ):
                listener.exitChange_over_time_config(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChange_over_time_config" ):
                return visitor.visitChange_over_time_config(self)
            else:
                return visitor.visitChildren(self)




    def change_over_time_config(self):

        localctx = SodaCLAntlrParser.Change_over_time_configContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_change_over_time_config)
        try:
            self.state = 166
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SodaCLAntlrParser.AVG, SodaCLAntlrParser.MIN, SodaCLAntlrParser.MAX]:
                self.enterOuterAlt(localctx, 1)
                self.state = 158
                self.change_aggregation()
                self.state = 159
                self.match(SodaCLAntlrParser.S)
                self.state = 160
                self.match(SodaCLAntlrParser.LAST)
                self.state = 161
                self.match(SodaCLAntlrParser.S)
                self.state = 162
                self.integer()
                pass
            elif token in [SodaCLAntlrParser.T__4]:
                self.enterOuterAlt(localctx, 2)
                self.state = 164
                self.match(SodaCLAntlrParser.T__4)
                pass
            elif token in [SodaCLAntlrParser.T__5]:
                self.enterOuterAlt(localctx, 3)
                self.state = 165
                self.match(SodaCLAntlrParser.T__5)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Change_aggregationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AVG(self):
            return self.getToken(SodaCLAntlrParser.AVG, 0)

        def MIN(self):
            return self.getToken(SodaCLAntlrParser.MIN, 0)

        def MAX(self):
            return self.getToken(SodaCLAntlrParser.MAX, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_change_aggregation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChange_aggregation" ):
                listener.enterChange_aggregation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChange_aggregation" ):
                listener.exitChange_aggregation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChange_aggregation" ):
                return visitor.visitChange_aggregation(self)
            else:
                return visitor.visitChildren(self)




    def change_aggregation(self):

        localctx = SodaCLAntlrParser.Change_aggregationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_change_aggregation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SodaCLAntlrParser.AVG) | (1 << SodaCLAntlrParser.MIN) | (1 << SodaCLAntlrParser.MAX))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PercentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_percent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercent" ):
                listener.enterPercent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercent" ):
                listener.exitPercent(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPercent" ):
                return visitor.visitPercent(self)
            else:
                return visitor.visitChildren(self)




    def percent(self):

        localctx = SodaCLAntlrParser.PercentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_percent)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 170
            self.match(SodaCLAntlrParser.T__6)
            self.state = 171
            self.match(SodaCLAntlrParser.S)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Anomaly_scoreContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_anomaly_score

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnomaly_score" ):
                listener.enterAnomaly_score(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnomaly_score" ):
                listener.exitAnomaly_score(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnomaly_score" ):
                return visitor.visitAnomaly_score(self)
            else:
                return visitor.visitChildren(self)




    def anomaly_score(self):

        localctx = SodaCLAntlrParser.Anomaly_scoreContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_anomaly_score)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 173
            self.match(SodaCLAntlrParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MetricContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def metric_name(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Metric_nameContext,0)


        def metric_args(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Metric_argsContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_metric

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetric" ):
                listener.enterMetric(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetric" ):
                listener.exitMetric(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetric" ):
                return visitor.visitMetric(self)
            else:
                return visitor.visitChildren(self)




    def metric(self):

        localctx = SodaCLAntlrParser.MetricContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_metric)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 175
            self.metric_name()
            self.state = 177
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SodaCLAntlrParser.ROUND_LEFT:
                self.state = 176
                self.metric_args()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Metric_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_metric_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetric_name" ):
                listener.enterMetric_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetric_name" ):
                listener.exitMetric_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetric_name" ):
                return visitor.visitMetric_name(self)
            else:
                return visitor.visitChildren(self)




    def metric_name(self):

        localctx = SodaCLAntlrParser.Metric_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_metric_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 179
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Metric_argsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROUND_LEFT(self):
            return self.getToken(SodaCLAntlrParser.ROUND_LEFT, 0)

        def metric_arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SodaCLAntlrParser.Metric_argContext)
            else:
                return self.getTypedRuleContext(SodaCLAntlrParser.Metric_argContext,i)


        def ROUND_RIGHT(self):
            return self.getToken(SodaCLAntlrParser.ROUND_RIGHT, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.COMMA)
            else:
                return self.getToken(SodaCLAntlrParser.COMMA, i)

        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_metric_args

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetric_args" ):
                listener.enterMetric_args(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetric_args" ):
                listener.exitMetric_args(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetric_args" ):
                return visitor.visitMetric_args(self)
            else:
                return visitor.visitChildren(self)




    def metric_args(self):

        localctx = SodaCLAntlrParser.Metric_argsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_metric_args)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 181
            self.match(SodaCLAntlrParser.ROUND_LEFT)
            self.state = 182
            self.metric_arg()
            self.state = 188
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SodaCLAntlrParser.COMMA:
                self.state = 183
                self.match(SodaCLAntlrParser.COMMA)
                self.state = 184
                self.match(SodaCLAntlrParser.S)
                self.state = 185
                self.metric_arg()
                self.state = 190
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 191
            self.match(SodaCLAntlrParser.ROUND_RIGHT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Metric_argContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def signed_number(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Signed_numberContext,0)


        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_metric_arg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetric_arg" ):
                listener.enterMetric_arg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetric_arg" ):
                listener.exitMetric_arg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetric_arg" ):
                return visitor.visitMetric_arg(self)
            else:
                return visitor.visitChildren(self)




    def metric_arg(self):

        localctx = SodaCLAntlrParser.Metric_argContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_metric_arg)
        try:
            self.state = 195
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SodaCLAntlrParser.T__19, SodaCLAntlrParser.PLUS, SodaCLAntlrParser.MINUS, SodaCLAntlrParser.DIGITS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 193
                self.signed_number()
                pass
            elif token in [SodaCLAntlrParser.AVG, SodaCLAntlrParser.MIN, SodaCLAntlrParser.MAX, SodaCLAntlrParser.IDENTIFIER_DOUBLE_QUOTE, SodaCLAntlrParser.IDENTIFIER_BACKTICK, SodaCLAntlrParser.IDENTIFIER_UNQUOTED]:
                self.enterOuterAlt(localctx, 2)
                self.state = 194
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ThresholdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def comparator_threshold(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Comparator_thresholdContext,0)


        def between_threshold(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Between_thresholdContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_threshold

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThreshold" ):
                listener.enterThreshold(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThreshold" ):
                listener.exitThreshold(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThreshold" ):
                return visitor.visitThreshold(self)
            else:
                return visitor.visitChildren(self)




    def threshold(self):

        localctx = SodaCLAntlrParser.ThresholdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_threshold)
        try:
            self.state = 199
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SodaCLAntlrParser.NOT_EQUAL, SodaCLAntlrParser.NOT_EQUAL_SQL, SodaCLAntlrParser.LTE, SodaCLAntlrParser.GTE, SodaCLAntlrParser.EQUAL, SodaCLAntlrParser.LT, SodaCLAntlrParser.GT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 197
                self.comparator_threshold()
                pass
            elif token in [SodaCLAntlrParser.BETWEEN, SodaCLAntlrParser.NOT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 198
                self.between_threshold()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Between_thresholdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BETWEEN(self):
            return self.getToken(SodaCLAntlrParser.BETWEEN, 0)

        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def threshold_value(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SodaCLAntlrParser.Threshold_valueContext)
            else:
                return self.getTypedRuleContext(SodaCLAntlrParser.Threshold_valueContext,i)


        def AND(self):
            return self.getToken(SodaCLAntlrParser.AND, 0)

        def NOT(self):
            return self.getToken(SodaCLAntlrParser.NOT, 0)

        def SQUARE_LEFT(self):
            return self.getToken(SodaCLAntlrParser.SQUARE_LEFT, 0)

        def ROUND_LEFT(self):
            return self.getToken(SodaCLAntlrParser.ROUND_LEFT, 0)

        def SQUARE_RIGHT(self):
            return self.getToken(SodaCLAntlrParser.SQUARE_RIGHT, 0)

        def ROUND_RIGHT(self):
            return self.getToken(SodaCLAntlrParser.ROUND_RIGHT, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_between_threshold

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBetween_threshold" ):
                listener.enterBetween_threshold(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBetween_threshold" ):
                listener.exitBetween_threshold(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBetween_threshold" ):
                return visitor.visitBetween_threshold(self)
            else:
                return visitor.visitChildren(self)




    def between_threshold(self):

        localctx = SodaCLAntlrParser.Between_thresholdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_between_threshold)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 203
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SodaCLAntlrParser.NOT:
                self.state = 201
                self.match(SodaCLAntlrParser.NOT)
                self.state = 202
                self.match(SodaCLAntlrParser.S)


            self.state = 205
            self.match(SodaCLAntlrParser.BETWEEN)
            self.state = 206
            self.match(SodaCLAntlrParser.S)
            self.state = 208
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SodaCLAntlrParser.SQUARE_LEFT or _la==SodaCLAntlrParser.ROUND_LEFT:
                self.state = 207
                _la = self._input.LA(1)
                if not(_la==SodaCLAntlrParser.SQUARE_LEFT or _la==SodaCLAntlrParser.ROUND_LEFT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 210
            self.threshold_value()
            self.state = 211
            self.match(SodaCLAntlrParser.S)
            self.state = 212
            self.match(SodaCLAntlrParser.AND)
            self.state = 213
            self.match(SodaCLAntlrParser.S)
            self.state = 214
            self.threshold_value()
            self.state = 216
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SodaCLAntlrParser.SQUARE_RIGHT or _la==SodaCLAntlrParser.ROUND_RIGHT:
                self.state = 215
                _la = self._input.LA(1)
                if not(_la==SodaCLAntlrParser.SQUARE_RIGHT or _la==SodaCLAntlrParser.ROUND_RIGHT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Comparator_thresholdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def comparator(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.ComparatorContext,0)


        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def threshold_value(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Threshold_valueContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_comparator_threshold

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparator_threshold" ):
                listener.enterComparator_threshold(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparator_threshold" ):
                listener.exitComparator_threshold(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparator_threshold" ):
                return visitor.visitComparator_threshold(self)
            else:
                return visitor.visitChildren(self)




    def comparator_threshold(self):

        localctx = SodaCLAntlrParser.Comparator_thresholdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_comparator_threshold)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 218
            self.comparator()
            self.state = 219
            self.match(SodaCLAntlrParser.S)
            self.state = 220
            self.threshold_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Zones_thresholdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def outcome(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SodaCLAntlrParser.OutcomeContext)
            else:
                return self.getTypedRuleContext(SodaCLAntlrParser.OutcomeContext,i)


        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def zone_comparator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SodaCLAntlrParser.Zone_comparatorContext)
            else:
                return self.getTypedRuleContext(SodaCLAntlrParser.Zone_comparatorContext,i)


        def threshold_value(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SodaCLAntlrParser.Threshold_valueContext)
            else:
                return self.getTypedRuleContext(SodaCLAntlrParser.Threshold_valueContext,i)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_zones_threshold

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterZones_threshold" ):
                listener.enterZones_threshold(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitZones_threshold" ):
                listener.exitZones_threshold(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitZones_threshold" ):
                return visitor.visitZones_threshold(self)
            else:
                return visitor.visitChildren(self)




    def zones_threshold(self):

        localctx = SodaCLAntlrParser.Zones_thresholdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_zones_threshold)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 231 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 222
                    self.outcome()
                    self.state = 223
                    self.match(SodaCLAntlrParser.S)
                    self.state = 224
                    self.zone_comparator()
                    self.state = 225
                    self.match(SodaCLAntlrParser.S)
                    self.state = 226
                    self.threshold_value()
                    self.state = 227
                    self.match(SodaCLAntlrParser.S)
                    self.state = 228
                    self.zone_comparator()
                    self.state = 229
                    self.match(SodaCLAntlrParser.S)

                else:
                    raise NoViableAltException(self)
                self.state = 233 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,18,self._ctx)

            self.state = 235
            self.outcome()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OutcomeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WARN(self):
            return self.getToken(SodaCLAntlrParser.WARN, 0)

        def FAIL(self):
            return self.getToken(SodaCLAntlrParser.FAIL, 0)

        def PASS(self):
            return self.getToken(SodaCLAntlrParser.PASS, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_outcome

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOutcome" ):
                listener.enterOutcome(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOutcome" ):
                listener.exitOutcome(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOutcome" ):
                return visitor.visitOutcome(self)
            else:
                return visitor.visitChildren(self)




    def outcome(self):

        localctx = SodaCLAntlrParser.OutcomeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_outcome)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 237
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SodaCLAntlrParser.WARN) | (1 << SodaCLAntlrParser.FAIL) | (1 << SodaCLAntlrParser.PASS))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Zone_comparatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(SodaCLAntlrParser.LT, 0)

        def LTE(self):
            return self.getToken(SodaCLAntlrParser.LTE, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_zone_comparator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterZone_comparator" ):
                listener.enterZone_comparator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitZone_comparator" ):
                listener.exitZone_comparator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitZone_comparator" ):
                return visitor.visitZone_comparator(self)
            else:
                return visitor.visitChildren(self)




    def zone_comparator(self):

        localctx = SodaCLAntlrParser.Zone_comparatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_zone_comparator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 239
            _la = self._input.LA(1)
            if not(_la==SodaCLAntlrParser.LTE or _la==SodaCLAntlrParser.LT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(SodaCLAntlrParser.LT, 0)

        def LTE(self):
            return self.getToken(SodaCLAntlrParser.LTE, 0)

        def EQUAL(self):
            return self.getToken(SodaCLAntlrParser.EQUAL, 0)

        def GTE(self):
            return self.getToken(SodaCLAntlrParser.GTE, 0)

        def GT(self):
            return self.getToken(SodaCLAntlrParser.GT, 0)

        def NOT_EQUAL(self):
            return self.getToken(SodaCLAntlrParser.NOT_EQUAL, 0)

        def NOT_EQUAL_SQL(self):
            return self.getToken(SodaCLAntlrParser.NOT_EQUAL_SQL, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_comparator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparator" ):
                listener.enterComparator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparator" ):
                listener.exitComparator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparator" ):
                return visitor.visitComparator(self)
            else:
                return visitor.visitChildren(self)




    def comparator(self):

        localctx = SodaCLAntlrParser.ComparatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_comparator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 241
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SodaCLAntlrParser.NOT_EQUAL) | (1 << SodaCLAntlrParser.NOT_EQUAL_SQL) | (1 << SodaCLAntlrParser.LTE) | (1 << SodaCLAntlrParser.GTE) | (1 << SodaCLAntlrParser.EQUAL) | (1 << SodaCLAntlrParser.LT) | (1 << SodaCLAntlrParser.GT))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Threshold_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def signed_number(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Signed_numberContext,0)


        def PERCENT(self):
            return self.getToken(SodaCLAntlrParser.PERCENT, 0)

        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def freshness_threshold_value(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Freshness_threshold_valueContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_threshold_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThreshold_value" ):
                listener.enterThreshold_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThreshold_value" ):
                listener.exitThreshold_value(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThreshold_value" ):
                return visitor.visitThreshold_value(self)
            else:
                return visitor.visitChildren(self)




    def threshold_value(self):

        localctx = SodaCLAntlrParser.Threshold_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_threshold_value)
        self._la = 0 # Token type
        try:
            self.state = 251
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 243
                self.signed_number()
                self.state = 248
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
                if la_ == 1:
                    self.state = 245
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==SodaCLAntlrParser.S:
                        self.state = 244
                        self.match(SodaCLAntlrParser.S)


                    self.state = 247
                    self.match(SodaCLAntlrParser.PERCENT)


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 250
                self.freshness_threshold_value()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Freshness_threshold_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integer(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SodaCLAntlrParser.IntegerContext)
            else:
                return self.getTypedRuleContext(SodaCLAntlrParser.IntegerContext,i)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_freshness_threshold_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFreshness_threshold_value" ):
                listener.enterFreshness_threshold_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFreshness_threshold_value" ):
                listener.exitFreshness_threshold_value(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFreshness_threshold_value" ):
                return visitor.visitFreshness_threshold_value(self)
            else:
                return visitor.visitChildren(self)




    def freshness_threshold_value(self):

        localctx = SodaCLAntlrParser.Freshness_threshold_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_freshness_threshold_value)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 256 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 253
                    self.integer()
                    self.state = 254
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SodaCLAntlrParser.T__8) | (1 << SodaCLAntlrParser.T__9) | (1 << SodaCLAntlrParser.T__10))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

                else:
                    raise NoViableAltException(self)
                self.state = 258 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,22,self._ctx)

            self.state = 261
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SodaCLAntlrParser.DIGITS:
                self.state = 260
                self.integer()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Reference_checkContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def source_column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SodaCLAntlrParser.Source_column_nameContext)
            else:
                return self.getTypedRuleContext(SodaCLAntlrParser.Source_column_nameContext,i)


        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def target_column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SodaCLAntlrParser.Target_column_nameContext)
            else:
                return self.getTypedRuleContext(SodaCLAntlrParser.Target_column_nameContext,i)


        def ROUND_LEFT(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.ROUND_LEFT)
            else:
                return self.getToken(SodaCLAntlrParser.ROUND_LEFT, i)

        def ROUND_RIGHT(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.ROUND_RIGHT)
            else:
                return self.getToken(SodaCLAntlrParser.ROUND_RIGHT, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.COMMA)
            else:
                return self.getToken(SodaCLAntlrParser.COMMA, i)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_reference_check

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReference_check" ):
                listener.enterReference_check(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReference_check" ):
                listener.exitReference_check(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReference_check" ):
                return visitor.visitReference_check(self)
            else:
                return visitor.visitChildren(self)




    def reference_check(self):

        localctx = SodaCLAntlrParser.Reference_checkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_reference_check)
        self._la = 0 # Token type
        try:
            self.state = 303
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 263
                self.match(SodaCLAntlrParser.T__11)
                self.state = 264
                self.match(SodaCLAntlrParser.S)
                self.state = 265
                self.source_column_name()
                self.state = 266
                self.match(SodaCLAntlrParser.S)
                self.state = 267
                self.match(SodaCLAntlrParser.T__12)
                self.state = 268
                self.match(SodaCLAntlrParser.S)
                self.state = 269
                self.identifier()
                self.state = 270
                self.match(SodaCLAntlrParser.S)
                self.state = 271
                self.target_column_name()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 273
                self.match(SodaCLAntlrParser.T__11)
                self.state = 274
                self.match(SodaCLAntlrParser.S)
                self.state = 275
                self.match(SodaCLAntlrParser.ROUND_LEFT)
                self.state = 276
                self.source_column_name()
                self.state = 282
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==SodaCLAntlrParser.COMMA:
                    self.state = 277
                    self.match(SodaCLAntlrParser.COMMA)
                    self.state = 278
                    self.match(SodaCLAntlrParser.S)
                    self.state = 279
                    self.source_column_name()
                    self.state = 284
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 285
                self.match(SodaCLAntlrParser.ROUND_RIGHT)
                self.state = 286
                self.match(SodaCLAntlrParser.S)
                self.state = 287
                self.match(SodaCLAntlrParser.T__12)
                self.state = 288
                self.match(SodaCLAntlrParser.S)
                self.state = 289
                self.identifier()
                self.state = 290
                self.match(SodaCLAntlrParser.S)
                self.state = 291
                self.match(SodaCLAntlrParser.ROUND_LEFT)
                self.state = 292
                self.target_column_name()
                self.state = 298
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==SodaCLAntlrParser.COMMA:
                    self.state = 293
                    self.match(SodaCLAntlrParser.COMMA)
                    self.state = 294
                    self.match(SodaCLAntlrParser.S)
                    self.state = 295
                    self.target_column_name()
                    self.state = 300
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 301
                self.match(SodaCLAntlrParser.ROUND_RIGHT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Source_column_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_source_column_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSource_column_name" ):
                listener.enterSource_column_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSource_column_name" ):
                listener.exitSource_column_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSource_column_name" ):
                return visitor.visitSource_column_name(self)
            else:
                return visitor.visitChildren(self)




    def source_column_name(self):

        localctx = SodaCLAntlrParser.Source_column_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_source_column_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 305
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Target_column_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_target_column_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTarget_column_name" ):
                listener.enterTarget_column_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTarget_column_name" ):
                listener.exitTarget_column_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTarget_column_name" ):
                return visitor.visitTarget_column_name(self)
            else:
                return visitor.visitChildren(self)




    def target_column_name(self):

        localctx = SodaCLAntlrParser.Target_column_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_target_column_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 307
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Section_headerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_checks_header(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Table_checks_headerContext,0)


        def column_configurations_header(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Column_configurations_headerContext,0)


        def table_filter_header(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Table_filter_headerContext,0)


        def checks_for_each_dataset_header(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Checks_for_each_dataset_headerContext,0)


        def checks_for_each_column_header(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Checks_for_each_column_headerContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_section_header

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSection_header" ):
                listener.enterSection_header(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSection_header" ):
                listener.exitSection_header(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSection_header" ):
                return visitor.visitSection_header(self)
            else:
                return visitor.visitChildren(self)




    def section_header(self):

        localctx = SodaCLAntlrParser.Section_headerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_section_header)
        try:
            self.state = 314
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SodaCLAntlrParser.T__13]:
                self.enterOuterAlt(localctx, 1)
                self.state = 309
                self.table_checks_header()
                pass
            elif token in [SodaCLAntlrParser.T__15]:
                self.enterOuterAlt(localctx, 2)
                self.state = 310
                self.column_configurations_header()
                pass
            elif token in [SodaCLAntlrParser.T__14]:
                self.enterOuterAlt(localctx, 3)
                self.state = 311
                self.table_filter_header()
                pass
            elif token in [SodaCLAntlrParser.T__16, SodaCLAntlrParser.T__17]:
                self.enterOuterAlt(localctx, 4)
                self.state = 312
                self.checks_for_each_dataset_header()
                pass
            elif token in [SodaCLAntlrParser.T__18]:
                self.enterOuterAlt(localctx, 5)
                self.state = 313
                self.checks_for_each_column_header()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_checks_headerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def partition_name(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Partition_nameContext,0)


        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_table_checks_header

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_checks_header" ):
                listener.enterTable_checks_header(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_checks_header" ):
                listener.exitTable_checks_header(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTable_checks_header" ):
                return visitor.visitTable_checks_header(self)
            else:
                return visitor.visitChildren(self)




    def table_checks_header(self):

        localctx = SodaCLAntlrParser.Table_checks_headerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_table_checks_header)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 316
            self.match(SodaCLAntlrParser.T__13)
            self.state = 317
            self.match(SodaCLAntlrParser.S)
            self.state = 318
            self.identifier()
            self.state = 321
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SodaCLAntlrParser.S:
                self.state = 319
                self.match(SodaCLAntlrParser.S)
                self.state = 320
                self.partition_name()


            self.state = 323
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Partition_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SQUARE_LEFT(self):
            return self.getToken(SodaCLAntlrParser.SQUARE_LEFT, 0)

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def SQUARE_RIGHT(self):
            return self.getToken(SodaCLAntlrParser.SQUARE_RIGHT, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_partition_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartition_name" ):
                listener.enterPartition_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartition_name" ):
                listener.exitPartition_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPartition_name" ):
                return visitor.visitPartition_name(self)
            else:
                return visitor.visitChildren(self)




    def partition_name(self):

        localctx = SodaCLAntlrParser.Partition_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_partition_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 325
            self.match(SodaCLAntlrParser.SQUARE_LEFT)
            self.state = 326
            self.identifier()
            self.state = 327
            self.match(SodaCLAntlrParser.SQUARE_RIGHT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_filter_headerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.S)
            else:
                return self.getToken(SodaCLAntlrParser.S, i)

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def partition_name(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.Partition_nameContext,0)


        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_table_filter_header

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_filter_header" ):
                listener.enterTable_filter_header(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_filter_header" ):
                listener.exitTable_filter_header(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTable_filter_header" ):
                return visitor.visitTable_filter_header(self)
            else:
                return visitor.visitChildren(self)




    def table_filter_header(self):

        localctx = SodaCLAntlrParser.Table_filter_headerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_table_filter_header)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 329
            self.match(SodaCLAntlrParser.T__14)
            self.state = 330
            self.match(SodaCLAntlrParser.S)
            self.state = 331
            self.identifier()
            self.state = 332
            self.match(SodaCLAntlrParser.S)
            self.state = 333
            self.partition_name()
            self.state = 334
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_configurations_headerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_column_configurations_header

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_configurations_header" ):
                listener.enterColumn_configurations_header(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_configurations_header" ):
                listener.exitColumn_configurations_header(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumn_configurations_header" ):
                return visitor.visitColumn_configurations_header(self)
            else:
                return visitor.visitChildren(self)




    def column_configurations_header(self):

        localctx = SodaCLAntlrParser.Column_configurations_headerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_column_configurations_header)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 336
            self.match(SodaCLAntlrParser.T__15)
            self.state = 337
            self.match(SodaCLAntlrParser.S)
            self.state = 338
            self.identifier()
            self.state = 339
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Checks_for_each_dataset_headerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_checks_for_each_dataset_header

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChecks_for_each_dataset_header" ):
                listener.enterChecks_for_each_dataset_header(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChecks_for_each_dataset_header" ):
                listener.exitChecks_for_each_dataset_header(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChecks_for_each_dataset_header" ):
                return visitor.visitChecks_for_each_dataset_header(self)
            else:
                return visitor.visitChildren(self)




    def checks_for_each_dataset_header(self):

        localctx = SodaCLAntlrParser.Checks_for_each_dataset_headerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_checks_for_each_dataset_header)
        try:
            self.state = 351
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SodaCLAntlrParser.T__16]:
                self.enterOuterAlt(localctx, 1)
                self.state = 341
                self.match(SodaCLAntlrParser.T__16)
                self.state = 342
                self.match(SodaCLAntlrParser.S)
                self.state = 343
                self.identifier()
                self.state = 344
                self.match(SodaCLAntlrParser.EOF)
                pass
            elif token in [SodaCLAntlrParser.T__17]:
                self.enterOuterAlt(localctx, 2)
                self.state = 346
                self.match(SodaCLAntlrParser.T__17)
                self.state = 347
                self.match(SodaCLAntlrParser.S)
                self.state = 348
                self.identifier()
                self.state = 349
                self.match(SodaCLAntlrParser.EOF)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Checks_for_each_column_headerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def S(self):
            return self.getToken(SodaCLAntlrParser.S, 0)

        def identifier(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IdentifierContext,0)


        def EOF(self):
            return self.getToken(SodaCLAntlrParser.EOF, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_checks_for_each_column_header

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChecks_for_each_column_header" ):
                listener.enterChecks_for_each_column_header(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChecks_for_each_column_header" ):
                listener.exitChecks_for_each_column_header(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChecks_for_each_column_header" ):
                return visitor.visitChecks_for_each_column_header(self)
            else:
                return visitor.visitChildren(self)




    def checks_for_each_column_header(self):

        localctx = SodaCLAntlrParser.Checks_for_each_column_headerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_checks_for_each_column_header)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 353
            self.match(SodaCLAntlrParser.T__18)
            self.state = 354
            self.match(SodaCLAntlrParser.S)
            self.state = 355
            self.identifier()
            self.state = 356
            self.match(SodaCLAntlrParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Signed_numberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def number(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.NumberContext,0)


        def PLUS(self):
            return self.getToken(SodaCLAntlrParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(SodaCLAntlrParser.MINUS, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_signed_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSigned_number" ):
                listener.enterSigned_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSigned_number" ):
                listener.exitSigned_number(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSigned_number" ):
                return visitor.visitSigned_number(self)
            else:
                return visitor.visitChildren(self)




    def signed_number(self):

        localctx = SodaCLAntlrParser.Signed_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_signed_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 359
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SodaCLAntlrParser.PLUS or _la==SodaCLAntlrParser.MINUS:
                self.state = 358
                _la = self._input.LA(1)
                if not(_la==SodaCLAntlrParser.PLUS or _la==SodaCLAntlrParser.MINUS):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 361
            self.number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def integer(self):
            return self.getTypedRuleContext(SodaCLAntlrParser.IntegerContext,0)


        def DIGITS(self, i:int=None):
            if i is None:
                return self.getTokens(SodaCLAntlrParser.DIGITS)
            else:
                return self.getToken(SodaCLAntlrParser.DIGITS, i)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumber" ):
                return visitor.visitNumber(self)
            else:
                return visitor.visitChildren(self)




    def number(self):

        localctx = SodaCLAntlrParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_number)
        self._la = 0 # Token type
        try:
            self.state = 374
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,33,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 363
                self.integer()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 364
                self.match(SodaCLAntlrParser.DIGITS)
                self.state = 365
                self.match(SodaCLAntlrParser.T__19)
                self.state = 367
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SodaCLAntlrParser.DIGITS:
                    self.state = 366
                    self.match(SodaCLAntlrParser.DIGITS)


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 370
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SodaCLAntlrParser.DIGITS:
                    self.state = 369
                    self.match(SodaCLAntlrParser.DIGITS)


                self.state = 372
                self.match(SodaCLAntlrParser.T__19)
                self.state = 373
                self.match(SodaCLAntlrParser.DIGITS)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntegerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGITS(self):
            return self.getToken(SodaCLAntlrParser.DIGITS, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_integer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInteger" ):
                listener.enterInteger(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInteger" ):
                listener.exitInteger(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInteger" ):
                return visitor.visitInteger(self)
            else:
                return visitor.visitChildren(self)




    def integer(self):

        localctx = SodaCLAntlrParser.IntegerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_integer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 376
            self.match(SodaCLAntlrParser.DIGITS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER_UNQUOTED(self):
            return self.getToken(SodaCLAntlrParser.IDENTIFIER_UNQUOTED, 0)

        def IDENTIFIER_DOUBLE_QUOTE(self):
            return self.getToken(SodaCLAntlrParser.IDENTIFIER_DOUBLE_QUOTE, 0)

        def IDENTIFIER_BACKTICK(self):
            return self.getToken(SodaCLAntlrParser.IDENTIFIER_BACKTICK, 0)

        def MIN(self):
            return self.getToken(SodaCLAntlrParser.MIN, 0)

        def MAX(self):
            return self.getToken(SodaCLAntlrParser.MAX, 0)

        def AVG(self):
            return self.getToken(SodaCLAntlrParser.AVG, 0)

        def getRuleIndex(self):
            return SodaCLAntlrParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifier" ):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = SodaCLAntlrParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_identifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 378
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SodaCLAntlrParser.AVG) | (1 << SodaCLAntlrParser.MIN) | (1 << SodaCLAntlrParser.MAX) | (1 << SodaCLAntlrParser.IDENTIFIER_DOUBLE_QUOTE) | (1 << SodaCLAntlrParser.IDENTIFIER_BACKTICK) | (1 << SodaCLAntlrParser.IDENTIFIER_UNQUOTED))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





