import os
from unittest.mock import Mock

import pytest
from helpers.test_connection import TestConnection
from helpers.test_fixtures import test_datasource

# define environment variables used in test cases
TRINO_HOST = os.getenv("TRINO_HOST", "")
TRINO_PORT = os.getenv("TRINO_PORT", 443)
TRINO_USERNAME = os.getenv("TRINO_USERNAME", "")
TRINO_PASSWORD = os.getenv("TRINO_PASSWORD", "")
TRINO_CATALOG = os.getenv("TRINO_CATALOG", "")
TRINO_JWT_TOKEN = os.getenv("TRINO_JWT_TOKEN", "")
TRINO_VERIFY = os.getenv("TRINO_VERIFY", "true")
# unsecured JWT token generated by https://jwt.io/ with header { "alg": "none" } and payload {}
FAKE_JWT_TOKEN = "eyJhbGciOiJub25lIn0.e30."


def mock_requests_post(token_url: str, data: dict) -> Mock:
    response = Mock()
    response.status_code = 200
    response.json.return_value = {"access_token": FAKE_JWT_TOKEN}
    return response


# define test cases and expected behavior (passing unless otherwise specified)
test_connections: list[TestConnection] = [
    TestConnection(  # correct connection, should work
        test_name="correct_username_password",
        connection_yaml_str=f"""
                type: trino
                name: TRINO_TEST_DS
                connection:
                    host: '{TRINO_HOST}'
                    port: {TRINO_PORT}
                    user: '{TRINO_USERNAME}'
                    password: '{TRINO_PASSWORD}'
                    catalog: '{TRINO_CATALOG}'
                    verify: {TRINO_VERIFY}
            """,
    ),
    TestConnection(  # correct connection, should work
        test_name="auth_type_username_password",
        connection_yaml_str=f"""
                type: trino
                name: TRINO_TEST_DS
                connection:
                    host: '{TRINO_HOST}'
                    port: {TRINO_PORT}
                    user: '{TRINO_USERNAME}'
                    password: '{TRINO_PASSWORD}'
                    catalog: '{TRINO_CATALOG}'
                    auth_type: 'BasicAuthentication'
                    verify: {TRINO_VERIFY}
            """,
    ),
    TestConnection(  # bad connection params
        test_name="auth_type_username_password_missing",
        valid_yaml=False,
        expected_yaml_error="password\n  Field required [type=missing,",
        connection_yaml_str=f"""
                type: trino
                name: TRINO_TEST_DS
                connection:
                    host: '{TRINO_HOST}'
                    port: {TRINO_PORT}
                    user: '{TRINO_USERNAME}'
                    catalog: '{TRINO_CATALOG}'
                    verify: {TRINO_VERIFY}
            """,
    ),
    TestConnection(  # correct connection, should work
        test_name="correct_username_password_with_options",
        connection_yaml_str=f"""
                type: trino
                name: TRINO_TEST_DS
                connection:
                    host: '{TRINO_HOST}'
                    port: {TRINO_PORT}
                    user: '{TRINO_USERNAME}'
                    password: '{TRINO_PASSWORD}'
                    catalog: '{TRINO_CATALOG}'
                    verify: {TRINO_VERIFY}
                    http_scheme: 'https'
                    http_headers:
                    source: 'soda-core'
                    client_tags:
                        - 'soda-core'
            """,
    ),
    TestConnection(  # fake unsecured token, will connect but fail at query stage
        test_name="jwt_auth",
        connection_yaml_str=f"""
                type: trino
                name: TRINO_TEST_DS
                connection:
                    host: '{TRINO_HOST}'
                    port: {TRINO_PORT}
                    catalog: '{TRINO_CATALOG}'
                    auth_type: 'JWTAuthentication'
                    access_token: '{FAKE_JWT_TOKEN}'
                    verify: {TRINO_VERIFY}
            """,
        query_should_succeed=False,
        expected_query_error="disallowed",
    ),
    TestConnection(  # fake unsecured token, will connect but fail at query stage
        test_name="oauth",
        connection_yaml_str=f"""
                type: trino
                name: TRINO_TEST_DS
                connection:
                    host: '{TRINO_HOST}'
                    port: {TRINO_PORT}
                    catalog: '{TRINO_CATALOG}'
                    verify: {TRINO_VERIFY}
                    auth_type: 'OAuth2ClientCredentialsAuthentication'
                    oauth:
                        token_url: 'https://example.com/token'
                        client_id: 'client_id'
                        client_secret: 'client_secret'
            """,
        query_should_succeed=False,
        expected_query_error="disallowed",
        monkeypatches={"requests.post": mock_requests_post},
    ),
    TestConnection(  # fake unsecured token, will connect but fail at query stage
        test_name="oauth_extra_params",
        connection_yaml_str=f"""
                type: trino
                name: TRINO_TEST_DS
                connection:
                    host: '{TRINO_HOST}'
                    port: {TRINO_PORT}
                    catalog: '{TRINO_CATALOG}'
                    verify: {TRINO_VERIFY}
                    auth_type: 'OAuth2ClientCredentialsAuthentication'
                    oauth:
                        token_url: 'https://example.com/token'
                        client_id: 'client_id'
                        client_secret: 'client_secret'
                        scope: 'scope1 scope2'
                        grant_type: 'grant_type'
            """,
        query_should_succeed=False,
        expected_query_error="disallowed",
        monkeypatches={"requests.post": mock_requests_post},
    ),
    TestConnection(  # invalid auth_type should produce clear error
        test_name="invalid_auth_type",
        valid_yaml=False,
        expected_yaml_error="Unknown Trino auth_type: 'InvalidAuth'",
        connection_yaml_str=f"""
                type: trino
                name: TRINO_TEST_DS
                connection:
                    host: '{TRINO_HOST}'
                    port: {TRINO_PORT}
                    catalog: '{TRINO_CATALOG}'
                    auth_type: 'InvalidAuth'
                    verify: {TRINO_VERIFY}
            """,
    ),
    TestConnection(  # JWT without access_token should show single clear error
        test_name="jwt_missing_access_token",
        valid_yaml=False,
        expected_yaml_error="access_token",
        connection_yaml_str=f"""
                type: trino
                name: TRINO_TEST_DS
                connection:
                    host: '{TRINO_HOST}'
                    port: {TRINO_PORT}
                    catalog: '{TRINO_CATALOG}'
                    auth_type: 'JWTAuthentication'
                    verify: {TRINO_VERIFY}
            """,
    ),
    TestConnection(  # OAuth without oauth block should show single clear error
        test_name="oauth_missing_payload",
        valid_yaml=False,
        expected_yaml_error="oauth",
        connection_yaml_str=f"""
                type: trino
                name: TRINO_TEST_DS
                connection:
                    host: '{TRINO_HOST}'
                    port: {TRINO_PORT}
                    catalog: '{TRINO_CATALOG}'
                    auth_type: 'OAuth2ClientCredentialsAuthentication'
                    verify: {TRINO_VERIFY}
            """,
    ),
    # uncomment the following to test JWT auth if you have a real token in TRINO_JWT_TOKEN
    # see soda-trino/local_instance/README.md to configure a local instance and generate a token you can use to run this test
    # last successful test: 2026-02-09
    # TestConnection(  # real token, should work
    #     test_name="real_jwt_token",
    #     connection_yaml_str=f"""
    #             type: trino
    #             name: TRINO_TEST_DS
    #             connection:
    #                 host: '{TRINO_HOST}'
    #                 port: '{TRINO_PORT}'
    #                 catalog: '{TRINO_CATALOG}'
    #                 auth_type: 'JWTAuthentication'
    #                 access_token: '{TRINO_JWT_TOKEN}'
    #                 verify: false
    #         """,
    # ),
]


# run tests.  parameterization means each test case will show up as an individual test
@pytest.mark.skipif(test_datasource != "trino", reason="Only test for Trino")
@pytest.mark.parametrize("test_connection", test_connections, ids=[tc.test_name for tc in test_connections])
def test_trino_connections(test_connection: TestConnection, monkeypatch: pytest.MonkeyPatch):
    test_connection.test(monkeypatch=monkeypatch)
