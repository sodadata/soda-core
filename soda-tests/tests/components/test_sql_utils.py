# ------------------------------
#
# DISCLAIMER: Fully generated by AI, validated and by human.
#
# ------------------------------

import pytest
import sqlglot
from soda_core.common.soda_cloud_dto import SamplerType
from soda_core.common.sql_utils import apply_sampling_to_sql
from sqlglot import exp


def _get_first_table(tree: exp.Expression, name: str) -> exp.Table:
    for t in tree.find_all(exp.Table):
        # t.this is an Identifier
        if getattr(t.this, "this", None) == name:
            return t
    raise AssertionError(f"Table {name!r} not found in AST")


def _get_first_subquery_with_alias(tree: exp.Expression, alias: str) -> exp.Subquery:
    for s in tree.find_all(exp.Subquery):
        a = s.args.get("alias")
        if a and getattr(a.this, "this", None) == alias:
            return s
    raise AssertionError(f"Subquery with alias {alias!r} not found in AST")


# ------------------------------
# basic validation
# ------------------------------


@pytest.mark.parametrize("sampler_limit", [0, -1])
def test_apply_sampling_invalid_limit_raises(sampler_limit: int) -> None:
    with pytest.raises(ValueError, match="sampler_limit must be positive"):
        apply_sampling_to_sql(
            sql="SELECT * FROM t",
            sampler_limit=sampler_limit,
            sampler_type=SamplerType.ABSOLUTE_LIMIT,
        )


def test_apply_sampling_unsupported_sampler_type_raises() -> None:
    with pytest.raises(ValueError, match="Unsupported sample type"):
        # Passing a bogus value is enough to trigger the branch
        apply_sampling_to_sql(
            sql="SELECT * FROM t",
            sampler_limit=10,
            sampler_type="FOO",  # type: ignore[arg-type]
        )


# ------------------------------
# simple FROM
# ------------------------------


def test_apply_sampling_simple_from_adds_sample_on_table() -> None:
    sql = "SELECT * FROM t"
    out = apply_sampling_to_sql(
        sql=sql,
        sampler_limit=10,
        sampler_type=SamplerType.ABSOLUTE_LIMIT,
    )

    tree = sqlglot.parse_one(out)
    t = _get_first_table(tree, "t")

    sample = t.args.get("sample")
    assert isinstance(sample, exp.TableSample)

    size = sample.args.get("size")
    assert isinstance(size, exp.Literal)
    assert size.this == "10"


def test_apply_sampling_preserves_alias() -> None:
    sql = "SELECT * FROM t AS x"
    out = apply_sampling_to_sql(
        sql=sql,
        sampler_limit=5,
        sampler_type=SamplerType.ABSOLUTE_LIMIT,
    )

    tree = sqlglot.parse_one(out)
    t = _get_first_table(tree, "t")

    alias = t.args.get("alias")
    assert alias is not None
    assert getattr(alias.this, "this", None) == "x"

    sample = t.args.get("sample")
    assert isinstance(sample, exp.TableSample)
    size = sample.args.get("size")
    assert isinstance(size, exp.Literal)
    assert size.this == "5"


# ------------------------------
# CTEs and nested subqueries
# ------------------------------


def test_apply_sampling_on_cte_and_outer_query() -> None:
    sql = """
        WITH cte AS (
            SELECT *
            FROM t1
        )
        SELECT *
        FROM cte
    """
    out = apply_sampling_to_sql(
        sql=sql,
        sampler_limit=10,
        sampler_type=SamplerType.ABSOLUTE_LIMIT,
    )

    tree = sqlglot.parse_one(out)

    # t1 in CTE body
    t1 = _get_first_table(tree, "t1")
    sample1 = t1.args.get("sample")
    assert isinstance(sample1, exp.TableSample)
    size1 = sample1.args.get("size")
    assert isinstance(size1, exp.Literal)
    assert size1.this == "10"

    # cte as FROM source in outer query is represented as a Table
    cte_table = _get_first_table(tree, "cte")
    assert isinstance(cte_table, exp.Table)
    assert cte_table.args.get("sample") is None


def test_apply_sampling_on_nested_subquery_in_join_and_from() -> None:
    sql = """
        WITH cte AS (
            SELECT *
            FROM t1
            WHERE x IN (SELECT y FROM t2)
        )
        SELECT *
        FROM cte c
        JOIN (SELECT * FROM t3) t ON c.id = t.id
    """
    out = apply_sampling_to_sql(
        sql=sql,
        sampler_limit=7,
        sampler_type=SamplerType.ABSOLUTE_LIMIT,
    )

    tree = sqlglot.parse_one(out)

    # t1 in CTE
    t1 = _get_first_table(tree, "t1")
    s1 = t1.args.get("sample")
    assert isinstance(s1, exp.TableSample)
    assert isinstance(s1.args.get("size"), exp.Literal)
    assert s1.args["size"].this == "7"

    # t2 in subquery in WHERE
    t2 = _get_first_table(tree, "t2")
    s2 = t2.args.get("sample")
    assert isinstance(s2, exp.TableSample)
    assert isinstance(s2.args.get("size"), exp.Literal)
    assert s2.args["size"].this == "7"

    # cte as FROM in outer query
    cte_table = _get_first_table(tree, "cte")
    sc = cte_table.args.get("sample")
    assert isinstance(sc, exp.TableSample)
    assert isinstance(sc.args.get("size"), exp.Literal)
    assert sc.args["size"].this == "7"

    # t3 inside derived table in JOIN
    t3 = _get_first_table(tree, "t3")
    s3 = t3.args.get("sample")
    assert isinstance(s3, exp.TableSample)
    assert isinstance(s3.args.get("size"), exp.Literal)
    assert s3.args["size"].this == "7"

    # the derived table itself (SELECT * FROM t3) should also be sampled
    subquery = _get_first_subquery_with_alias(tree, "t")
    sq_sample = subquery.args.get("sample")
    assert isinstance(sq_sample, exp.TableSample)
    assert isinstance(sq_sample.args.get("size"), exp.Literal)
    assert sq_sample.args["size"].this == "7"


# ------------------------------
# existing SAMPLE is preserved
# ------------------------------


def test_apply_sampling_does_not_override_existing_sample() -> None:
    sql = "SELECT * FROM t TABLESAMPLE(5)"
    out = apply_sampling_to_sql(
        sql=sql,
        sampler_limit=10,
        sampler_type=SamplerType.ABSOLUTE_LIMIT,
    )

    tree = sqlglot.parse_one(out)
    t = _get_first_table(tree, "t")

    sample = t.args.get("sample")
    assert isinstance(sample, exp.TableSample)

    # existing sample size should remain 5, not be replaced by 10
    size = sample.args.get("size")
    assert isinstance(size, exp.Literal)
    assert size.this == "5"


# ------------------------------
# Subquery test
# ------------------------------


def test_apply_sampling_complex_query() -> None:
    sql = """
        SELECT COUNT(*)
            FROM (
                SELECT
                CASE WHEN
                    FIELD_NK1 not regexp '[1-6]|[a-z0-9]{8}(-[a-z0-9]{4}){3}-[a-z0-9]{12}|[0-9]{4}|-[12]|Ambient'
                OR
                    IFF(try_cast(TO_CHAR(FIELD_NK1) as TEXT) IN (select distinct FIELD_NK1 from MY_DB.MY_SCHEMA.T1), FALSE, TRUE)
                THEN TRUE ELSE FALSE
                END as check_result
                FROM
                    MY_DB.MY_SCHEMA.T2
            ) subquery
        WHERE check_result = TRUE;"""
    out = apply_sampling_to_sql(
        sql=sql,
        sampler_limit=15,
        sampler_type=SamplerType.ABSOLUTE_LIMIT,
    )
    # Check that the output SQL contains the expected TABLESAMPLE clauses
    tree = sqlglot.parse_one(out)
    t1 = _get_first_table(tree, "T1")
    sample1 = t1.args.get("sample")
    assert isinstance(sample1, exp.TableSample)
    size1 = sample1.args.get("size")
    assert isinstance(size1, exp.Literal)
    assert size1.this == "15"

    t2 = _get_first_table(tree, "T2")
    sample2 = t2.args.get("sample")
    assert isinstance(sample2, exp.TableSample)
    size2 = sample2.args.get("size")
    assert isinstance(size2, exp.Literal)
    assert size2.this == "15"

    # Make sure that the subselect itself is not sampled since it's already sampled at its definition
    subquery = _get_first_subquery_with_alias(tree, "subquery")
    subquery_sample = subquery.args.get("sample")
    assert subquery_sample is None
    print(out)
    assert 1 == 2
